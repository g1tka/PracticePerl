use strict;
use warnings;

my @score = (64, 90, 75);
# 配列。＠。@配列名。中身は「要素」。要素を取り出すには・・・
# print $score[0];
# ひとつ取り出すのはスカラー変数。$で指定。０～

# print $score[0] + $score[1] + $score[2], "\n";

my $sum = 0;
foreach my $item (@score) {
    $sum = $sum + $item;
}
print $sum, "\n";

# はじめに＝０と定義しているが、これは初期化している。
# foreach　繰り返しの構文を作るためのもの。
# 配列の要素を1個1個取り出して　→　$itemにセット。
# $sum（これまでの合計）＋ $item を左辺の $sum へ代入する。
# $sum += $item;でもよい。これは、$sum に $item を足し込んでいる。と。
# 変数省略がよく行われるとのこと。$item の部分を書かない。
# $_ が自動的に代わりとなる。何か要素を用いたいときはこれを記述することでアクセスできる。
foreach (@score) {
    $sum += $_;
}

# 配列に要素を追加したい場合
$score[3] = 100;
# print @score, "\n";
# デバッグプリント。649075100と表示された。いちおう、追加されたことを確認できた。

# 文字列も代入できる。qw()便利表記法を使うと、スペースを区切りとして、単語をリストの要素にする。
# my @week = qw(Sun Mon Tue Wed Thu Fri Sat);
my @week = ('Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat');
foreach my $day (@week) {
    print "$day ";
}
print "\n";
# デバッグプリントのための記述が一手間。連続して表示されてしまうのを防いだ。
# ""（二重引用符）中で展開すると！要素がスペースで区切られたものになる！！！！

print "@score\n";
print "@week\n";
print "国語は $score[0] 点です。\n";
# 簡単だ・・・

# @を含む文字列の出力（配列じゃない）（test\@mail.comなど）
print "test\@mail.com\n";

# 配列の要素数を調べるには、arrayをscalarに代入する。
my @array = (
    31,
    41,
    59,
    26,
);
my $length = @array;
print $length, "\n";
# 4
# 関数scalarを使ってもいい。強制的にスカラーコンテキストで評価することができる。
print scalar(@array), "\n";
# 以下は配列の大きさによって処理が変わるif文の例。
if (@array) {
    # 配列が空でない場合。@array > 0 と同じ。
} else {    # 配列が空の場合
}

# 配列の最後の要素を得たいとき。
my $last = $array[-1];
#        = $array[$#array];
print $last, "\n";
# 要素が４つの配列に対して、要素の添字は0,1,2,3。
# 最後の要素の添字 $#array == @array - 1; である。（真）

=pod
要素の交換　（$xと$yを交換したい）
$tmp = $x;
$x = $y;
$y = $tmp;
もしくは以下
($x, $y) = ($y, $x);
($x, $y, $z) = ($y, $z, $x);
=cut

=pod
要素の合体　（@user1という配列と@user2という配列をすべて前から順に合わせる）
my @users = (@user1, @user2);
@user1, @user2を書き換えても、合体した後であれば@usersが自動的に書き換わることはない。
print "@users\n";
=cut

# my @score = (64, 90, 75, 100);
# Perlの組み込み関数joinを使うと、配列の要素を連結して1つの文字列にすることができる。
print join(',', @score), "\n";
# 64, 90, 75
# join(区切り文字列(今回は","), 配列やリスト(期待))　という形式。
print '点数は' . join('点と、', (60, 90, 70)) . '点です。', "\n";
# 60, 90, 70　区切り文字は要素の合間に入り、最後の要素の後ろにはつかない。

# Perlの組み込み関数splitを使うと、文字列を分けられる。
my @score1 = split(/,/, '64,90,75');
print "@score1\n";
# split(/パターン/, 文字列)　という形式。第二引数のところ、文字列、なので数も文字列！！！
# 64 90 75　と出力される。　","を消した。
# //で囲うことで（正規表現）区切り文字列のパターンを表現。
my $line = 'Hello, world!';
my @array2 = split(//, $line);
print join(':', @array2), "\n";
# H:e:l:l:o:,: :w:o:r:l:d:! となる！
print join(':', @score), "\n";
# 64:90:75:100 となる！（それぞれが文字列）
=pod

なるほど利用例：アクセスカウンターの一部
$counter ：アクセスカウンタの数値が入っている（とする）
my $counter = 123;
my @counter = split(//, $counter);
foreach my $file (@counter) {
    print "<img src=\"$file.gif\">";
}
出力：<img src="1.gif"><img src="2.gif"><img src="3.gif">
もしくは・・・
my $counter = 123;foreach (split(//, $counter)) {
    print qq|<img src="$_.gif">|;
}
出力：<img src="1.gif"><img src="2.gif"><img src="3.gif">
=cut

# my @data = split(/ /, '  green  red    yellow  ');
# print "@data\n";
# print join(' ', @data),"\n";
# my @data = split(/\s+/, '  green  red    yellow  ');
# \sはスペースやタブなどの空白全般を意味する。メタ文字＋は一個以上の繰り返し。

# push(@array, 'LAST');# push関数。配列の最後に要素を付け加える。my @array3 = ('one', 'two', 'three');push(@array3, 'FOUR');print "\@array3 = @array3\n";# 配列が空の場合、一つ追加（最後についか）# 配列の最後に、要素だけでなく配列も追加できる。my @list2 = ('FOUR', 'FIVE', 'SIX');my @array4 = ('one', 'two', 'three');push(@array4, @list2);# もしくは　push(@array4, ('FOUR', 'FIVE', 'SIX'))print "\@array4 = @array4\n";
my $item = pop(@array3);print "pop後 \@array3 = @array3\n";print "\$item = $item\n";# (one two three)　→　FOUR# popを繰り返すと、配列の後ろから順番に取り出され、長さが１つずつ短くなる。# 再度、$item = pop(@array3);print "( @array3 ) → $item\n";# ( one two ) → three$item = pop(@array3);print "( @array3 ) → $item\n";# ( one ) → two$item = pop(@array3);print "( @array3 ) → $item\n";# (  ) → one# さらに実行しようとする。# $item = pop(@array3);# print "( @array3 ) → $item\n";# Use of uninitialized value $item in concatenation (.) or string at array1.pl line 166.# (  ) →# 上の二行が出力されたが、これはundefという未定義を表す特殊な値が返される。とのこと。# 「スタック」というデータ構造とみなし、後入れ先出し、Last In First Out, LIFO。
# shift関数は配列の最初の要素を取り出す。一つ前に、シフトする。my @array5 = ('one', 'two', 'three');my $item2 = shift(@array5);print "$item2 ← ( @array5 ) \n";# one ← ( two three )# unshift関数は逆に最初に要素を追加する。# unshift(@array, $item);my @array6 = unshift(@array5, $item2);print "$item2 →( @array5 )\n";print "\@array6 = 戻り値は要素数：( @array6 )\n";
=podまとめ。配列末尾に追加 push 取り出し pop配列戦闘に追加unshift 取り出し shift
push と pop でスタックという捉え方。後入れ先出し、Last In First Out, LIFO。shift と unshift でスタックという捉え方。push で追加していくがshiftで出されていくと　先入れ先出し。これは「キュー」というデータ構造。First In first Out, FIFO。push と shift でキューを構成することができる。先に並んだひとが、先に処理される、順番待ちもキュー。=cut
# splice(ARRAY, OFFSET, LENGTH, LIST) # splice(対象配列の, ここから, これだけの長さを削除し, そこにこのリストを挿入する)my @array7 = ('a', 'b', 'c', 'd', 'e', 'f');my @xyz = ('X', 'Y', 'Z');my @removed = splice(@array7, 1, 4, @xyz);print "\@array7 = @array7\n";print "\@removed = @removed\n";# @array7 = a X Y Z f# @removed = b c d e# spliceの戻り値は削除したリスト
my @array8 = ('a', 'b', 'c', 'd', 'e', 'f');my @removed2 = splice(@array8, 1, 4);print "\@array8 = @array8\n";print "\@removed2 = @removed2\n";# @array8 = a f# @removed2 = b c d e# 最後のLASTを省略すると、挿入は行われず、単なる削除になる。
my @array9 = ('a', 'b', 'c', 'd', 'e', 'f');my @removed3 = splice(@array9, 1);print "\@array9 = @array9\n";print "\@removed3 = @removed3\n";# @array9 = a# @removed3 = b c d e f# LASTに加えて、LENGTHも省略すると、長さ指定なし＝以降すべてが削除対象。
my @array10 = ('a', 'b', 'c', 'd', 'e', 'f');my @removed4 = splice(@array10);print "\@array10 = @array10\n";print "\@removed4 = @removed4\n";# @array10 =# @removed4 = a b c d e f# さらにOFFSETも省略すると、開始位置指定なし＝配列の最初の要素から# 最後まで、挿入するものナシ　→　すべて、削除、となる。